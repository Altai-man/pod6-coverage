use v6;
use Pod::Tester;
unit class Pod::Coverage::Full does Pod::Tester;
has $.toload;
has $.path;
has $.packageStr;

#| Normally if method is an accessor Pod::Coverage checks
#| field documentation (autogenerated accessors have no pod)
#| anyway they are often sefl documenting so checking it is
#|  disabled as default
has Bool $.ignore-accessors is rw = True;
#|Attribute list for skipping accessor methods
has @!currentAttr;


method check{
    require ::($!toload);
    #start from self        
    self.parse(::($!packageStr));
    self.correct-pod($!path);
}
#| Returns stringified version of results... in opposite to
#| raw C<@.results>
method get-results {
    gather {
        if @!results {   
            for @!results.values -> $result {
                if $result.^can("package") {
                    take $result.package.^name ~ "::" ~ $result.name ~ " has no pod";
                }
                else {
                    take $result.^name ~ " has no pod";
                }
            }
        } else {
            take $!packageStr ~ " has pod";
        }
    }

}

#| goes through metaobject tree and searches for .WHY
method parse($whoO) {
    if ($whoO.WHAT ~~ Routine) {
        # Because Routine is a class it must be checked before
        unless $whoO.WHY {
            if $whoO.WHAT ~~ Method {
                
                for @!currentAttr -> $attr {
                    if $attr.name.subst(/.\!/, "") ~~ $whoO.name {
                        
                        if $attr.has-accessor {
                            return if $!ignore-accessors;
                            unless $attr.WHY {
                                @!results.push: $attr;
                            }
                            return
                        }
                    }
                }
            }
            @!results.push: $whoO;
        }  
    }    
    elsif ($whoO.HOW ~~ Metamodel::PackageHOW) {
        for $whoO.WHO.values -> $clazz {
            self.parse($clazz); 
        }
    }
    elsif ($whoO.HOW ~~ Metamodel::ModuleHOW) {
        for $whoO.WHO.values -> $clazz {
            if $clazz.^name eq 'EXPORT' {
                for $clazz.WHO<ALL>.WHO.values -> $subr {
                    self.parse($subr);
                }

            } else {
                self.parse($clazz);
            }
            
        }
    } elsif ($whoO.HOW ~~ Metamodel::ClassHOW ) 
    {
        unless $whoO.WHY {
            @!results.push: $whoO;
        }
        
        @!currentAttr = $whoO.^attributes;
        
        for $whoO.^methods(:local) -> $m {                
            self.parse($m);
        }
        
        for $whoO.WHO<EXPORT>.WHO<ALL>.WHO.values -> $subr {   
            self.parse($subr);
        }
        
    }
    elsif ($whoO.HOW ~~ Metamodel::ParametricRoleGroupHOW) {
        for $whoO.^candidates -> $role {                
            self.parse($role);
        }
    }
    #        elsif ($whoO ~~ Grepper)
    #        {
    #todo

    #        }
    else {
        warn "What is " ~ $whoO.^name ~ " ?";
    }
}

#| Takes whole pod and corrects list made by C<method parse>
method correct-pod($filename) {
    my @keywords = read_pod($filename,True);
    @keywords.append(read_pod($filename.subst(/\.pm[6]*$/, '.pod'))); 
    
    my @new_results;
    for @!results -> $result {
        # HACK
        my $name = $result.can("package") ?? $result.name !! $result.^name;
        if $result.WHAT ~~ Sub {  
            @new_results.push: $result unless @keywords.first(/[sub|routine|subroutine]\s+$name/);                
        } elsif $result.WHAT ~~ Routine {
            @new_results.push: $result unless @keywords.first(/[method|routine]\s+$name/); 
        } else {
            @new_results.push: $result unless @keywords.first(/\s*$name/); 
        }
    }
    @!results =  @new_results;
    
}

sub read_pod($filename, $important=False){        
    return qqx/$*EXECUTABLE-NAME --doc=Keywords $filename/.lines;
    CATCH {
        return Empty;
    }    
}
